import { describe, expect, it, jest } from '@jest/globals';
// import * as path from 'path';
import { TestRunCfg } from "./TestRunCfg";

import * as general from './general'
jest.mock("./general")
const { nearestAncestor } = jest.mocked(general)

import * as fs from "fs"
jest.mock("fs")
const { readdirSync } = jest.mocked(fs)

const root = "/fake/root"
const here = `${root}/sub/path`
const name = "capability-name"
const me = `${here}/${name}.e2e.test.ts`

describe("TestRunCfg", () => {
  it("exposes given test file", () => {
    const trc = new TestRunCfg(me)
    expect(trc.me).toBe(me)
  })

  describe("exposes run-specific unique value", () => {
    it("can be autogenerated", () => {
      const trc = new TestRunCfg(me)
      expect(trc.unique).toBeTruthy()
    })

    it("can be given directly", () => {
      const unique = "set-explictly"
      const trc = new TestRunCfg(me, unique)
      expect(trc.unique).toBe(unique)
    })
  })

  describe("exposes kube config used for cluster operations", () => {
    it("defaults to widely-known default location", () => {
      const trc = new TestRunCfg(me)
      expect(trc.kubeConfig).toBe("~/.kube/config")
    })

    it("can be given directly", () => {
      const kubeConfig = "~/.config/k3d/cluster.yaml"
      const trc = new TestRunCfg(me, undefined, kubeConfig)
      expect(trc.kubeConfig).toBe(kubeConfig)
    })
  })

  it("derives capability name", () => {
    const trc = new TestRunCfg(me)
    expect(trc.name()).toBe(name)
  })

  it("derives capability path", () => {
    const trc = new TestRunCfg(me)
    expect(trc.here()).toBe(here)
  })

  it ("determines project root", () => {
    nearestAncestor.mockClear().mockImplementation((f, p) => {
      if (f === "package.json" && p === here) {
        return `${root}/package.json`
      } else { throw "" }
    })
    const trc = new TestRunCfg(me)
    expect(trc.root()).toBe(root)
  })

  it ("derives cluster lock file path", () => {
    const lock = `${root}/cluster.lock`
    const trc = new TestRunCfg(me)
    expect(trc.lockfile()).toBe(lock)
  })

  it("exposes a capability-specific label key", () => {
    const lk = `test-transient/${name}`
    const trc = new TestRunCfg(me)
    expect(trc.labelKey()).toBe(lk)
  })

  // it ("derives cluster module file path", () => {
  //   const mod = me.replace('.e2e.test', '.pepr')
  //   const trc = new TestRunCfg(me)
  //   expect(trc.module()).toBe(mod)
  // })

  // describe("discovers to-be-applied, index-ordered capability test manifests", () => {
  //   const files = [
  //     `${name}.test.0.yaml`,
  //     `${name}.test.8675309.yaml`,
  //     `${name}.test.09.yaml`,
  //     `${name}.test.8.yaml`,
  //     `${name}.test.1009.yaml`,
  //     `nope.test.1.yaml`
  //   ]
  //   const manifestList = [
  //     [`${here}/${name}.test.0.yaml`, `${here}/${name}.test.0.yaml.json`],
  //     [`${here}/${name}.test.8.yaml`, `${here}/${name}.test.8.yaml.json`],
  //     [`${here}/${name}.test.09.yaml`, `${here}/${name}.test.09.yaml.json`],
  //     [`${here}/${name}.test.1009.yaml`, `${here}/${name}.test.1009.yaml.json`],
  //     [`${here}/${name}.test.8675309.yaml`, `${here}/${name}.test.8675309.yaml.json`]
  //   ]

  //   beforeEach(() => {
  //     readdirSync.mockImplementation(
  //       ( () => files ) as unknown as typeof readdirSync
  //     )
  //   })

  //   it("exposes the ordered manifest lookup list", () => {
  //     const trc = new TestRunCfg(me)
  //     expect(trc.manifests()).not.toHaveLength(0)
  //     trc.manifests().forEach((manifest, idx) => {
  //       const [yaml, json] = manifest
  //       const [yexp, jexp] = manifestList[idx]
  //       expect(yaml).toBe(yexp)
  //       expect(json).toBe(jexp)
  //     })
  //   })

  //   it("exposes json manifest lookup-by-index-number method", () => {
  //     const trc = new TestRunCfg(me)

  //     const json = (i: number) => manifestList[i][1]
  //     expect(trc.manifest(0)).toBe(json(0))
  //     expect(trc.manifest(8)).toBe(json(1))
  //     expect(trc.manifest(9)).toBe(json(2))
  //     expect(trc.manifest(1009)).toBe(json(3))
  //     expect(trc.manifest(8675309)).toBe(json(4))
  //   })
  // })
})
